# Projet ft_transcendence

_ ilymegy

<!-- <p align="center">
  <img src="#" alt="ft_transcendence structure" width="400"/>
</p> -->

## **Sommaire**

- [Introduction](#0-introduction)
- [Comprendre le projet](#1-comprendre-le-projet)
- [Choix techniques](#2-choix-techniques)
- [Petit cours de web](#3-petit-cours-de-web)
- [Architecture du projet](#4-architecture-du-projet)
- [Setup](#5-setup)
- [Commandes utiles](#6-commandes-utiles)
- [D√©veloppement](#7-d√©veloppement-par-phases)
- [Checklist de progression](#8-checklist-de-progression)
- [Ressources utiles](#9-ressources-utiles)

### **0. Introduction**

Le projet **ft_transcendence** est le projet final du tronc commun de 42. Il consiste √† cr√©er une application web compl√®te centr√©e autour d'un jeu de Pong en ligne avec de nombreuses fonctionnalit√©s sociales et techniques. Ce projet met en avant l'utilisation de technologies web modernes, Docker, et l'architecture fullstack.

### **1. Comprendre le projet**

ft_transcendence est une application web qui permet de :

- Jouer au Pong en ligne contre d'autres joueurs
- G√©rer des profils utilisateurs avec authentification
- Cr√©er des tournois et suivre des statistiques
- Int√©grer des fonctionnalit√©s sociales (chat, amis, etc.)

#### **Pourquoi ce projet ?**

- Ma√Ætrise compl√®te du d√©veloppement web fullstack
- Compr√©hension des WebSockets pour le temps r√©el
- Gestion de la s√©curit√© web et de l'authentification
- Architecture d'applications complexes avec Docker

#### **Technologies recommand√©es**

- **Backend** : FastAPI/Django (Python) ou NestJS (TypeScript)
- **Frontend** : React/Vue.js ou Vanilla JavaScript
- **Base de donn√©es** : PostgreSQL
- **Containerisation** : Docker & Docker Compose
- **WebSockets** : Socket.io ou WebSocket natif

#### **Services Docker**

- **nginx** : Reverse proxy et serveur web
- **backend** : API REST et WebSockets
- **frontend** : Interface utilisateur
- **database** : PostgreSQL pour les donn√©es
- **redis** : Cache et sessions (optionnel)

#### **üéØ Partie obligatoire**

- Application web fonctionnelle
- Jeu Pong jouable en temps r√©el
- Authentification utilisateurs
- Interface utilisateur responsive
- Docker setup complet
- Base de donn√©es PostgreSQL
- S√©curit√© web (HTTPS, protection XSS/CSRF)

#### **üíé Modules bonus mineurs (5 points)**

- **Monitoring** : Prometheus + Grafana pour les m√©triques
- **Multiple Languages** : Support de 3+ langues
- **All Devices Support** : Responsive design complet
- **Browser Compatibility** : Support navigateurs suppl√©mentaires
- **Accessibility** : Support utilisateurs malvoyants
- **SSR Integration** : Server-Side Rendering

---

### **2. Choix techniques**

#### **Vite : L'outil de build ultra-rapide**

Vite est un outil de build moderne qui am√©liore consid√©rablement l'exp√©rience de d√©veloppement frontend.

***Avantages cl√©s***

- **D√©marrage instantan√© du serveur** : Contrairement √† Create React App qui peut prendre plusieurs secondes, Vite d√©marre en quelques millisecondes.
- **HMR (Hot Module Replacement) ultra-rapide** : Les modifications dans le code sont refl√©t√©es instantan√©ment dans le navigateur, sans rechargement complet de la page.
- **Optimisation des performances** :
  - **ESM natif** : Utilise les modules ES natifs du navigateur
  - **Chargement √† la vol√©e** : Ne compile que les fichiers n√©cessaires
  - **Pr√©-compilation des d√©pendances** : Les d√©pendances sont pr√©-compil√©es une seule fois
- **Configuration minimale** : Moins de fichiers de configuration que webpack, tout en restant personnalisable.

***Comparaison Vite vs Create React App (CRA)***

| Fonctionnalit√© | Vite | Create React App |
|----------------|------|-----------------|
| Temps de d√©marrage | ‚ö° Instantan√© | üê¢ Plus lent |
| HMR | ‚ö° Instantan√© | üê¢ Plus lent |
| Configuration | üîß Minimale | üì¶ Pr√©-configur√©e |
| Flexibilit√© | üî• Tr√®s flexible | üîÑ Moins flexible |
| Production Build | ‚ö° Ultra-rapide | üê¢ Plus lent |

***Pourquoi Vite pour ft_transcendence ?***

1. **Productivit√© accrue** : D√©veloppement plus fluide avec des rechargements quasi-instantan√©s
2. **Optimis√© pour ES Modules** : Parfait pour les projets modernes
3. **L√©ger et rapide** : Important pour une application de jeu comme Pong
4. **Support TypeScript natif** : Pas besoin de configuration suppl√©mentaire
5. **√âcosyst√®me riche** : Nombreux plugins officiels et communautaires

---

#### **Pourquoi NestJS + React ?**

| Crit√®re | NestJS + React (choisi) | Alternatives (FastAPI, Django) |
|---------|------------------------|--------------------------------|
| Langage partag√© | Tout en **TypeScript** ‚Üí partage de types entre front et back | Python ‚ÜîÔ∏é TypeScript : moins homog√®ne |
| WebSockets | Module d√©di√© `@nestjs/websockets` avec **Socket.io** int√©gr√© | Plus manuel (FastAPI) ou lourd (Django Channels) |
| Structure | Modules / Guards / Pipes ‚Üí code modulaire et clair | Monolithique ou non-structur√© |
| ORM | **Prisma** : sch√©ma d√©claratif, migrations simples | Alembic/SQLModel (FastAPI) ou Django ORM |

---

### **3. Petit cours de web**

#### **Qu'est-ce qu'une application web ?**

Imagine que tu veux cr√©er un restaurant :

üè™ Le restaurant = ton application web (ex: ton jeu Pong)
üë®‚Äçüç≥ La cuisine = le backend (l√† o√π on pr√©pare les plats)
üçΩÔ∏è La salle = le frontend (l√† o√π les clients mangent)
üìã Le carnet de commandes = la base de donn√©es (o√π on stocke les infos)
üö™ Le serveur = l'API (qui fait le lien entre cuisine et salle)

Concr√®tement pour ton projet Pong :
Frontend : ce que tu vois (le jeu, les boutons, les scores)
Backend : ce qui calcule (logique du jeu, qui gagne, sauvegarder les scores)
Base de donn√©es : o√π on stocke (profils joueurs, historique des parties)

---

#### **Les langages de base du web**

HTML = La structure (les murs de ta maison)

```html
<h1>Mon titre</h1>
<p>Mon paragraphe</p>
<button>Mon bouton</button>
```

C'est comme les murs et pi√®ces de ta maison.

CSS = Le style (la d√©coration)

```css
h1 { color: blue; font-size: 24px; }
```

C'est la peinture, les meubles, la d√©co.

JavaScript = L'interactivit√© (l'√©lectricit√©)

```javascript
button.onclick = function() { alert("Coucou !"); }
```

C'est ce qui fait que les lumi√®res s'allument quand tu appuies sur l'interrupteur.

---

#### **Client vs Serveur (la base de TOUT)**

Imagine que tu commandes une pizza :

üè† TOI (client) ‚Üê ‚Üí üçï PIZZERIA (serveur)

Tu demandes une pizza (requ√™te)
La pizzeria pr√©pare la pizza
La pizzeria te renvoie la pizza (r√©ponse)
En web :
üñ•Ô∏è TON NAVIGATEUR (client) ‚Üê ‚Üí üè¢ SERVEUR WEB (serveur)

Tu tapes google.com (requ√™te)
Le serveur Google pr√©pare la page
Google t'envoie la page HTML/CSS/JS (r√©ponse)

---

#### **Frontend vs Backend (en d√©tail)**

üé® FRONTEND = Ce que TU vois
O√π √ßa tourne : Dans ton navigateur (Chrome, Firefox...)
Langages : HTML, CSS, JavaScript
Exemples : Boutons, animations, formulaires, menus
‚öôÔ∏è BACKEND = Ce que tu NE vois PAS
O√π √ßa tourne : Sur un serveur (ordinateur distant)
Langages : Python, JavaScript (Node.js), Java, PHP...
Exemples : V√©rifier ton mot de passe, sauvegarder tes donn√©es, calculer ton score
üîÑ Comment ils communiquent ?
Via des API (Application Programming Interface) = des "portes" pour √©changer des infos.

Exemple concret avec ton Pong :

Tu cliques "Jouer" (frontend)
Le frontend dit au backend "Lance une partie !" (API)
Le backend cr√©e la partie et r√©pond "OK, partie cr√©√©e !" (API)
Le frontend affiche "Partie en cours..." (frontend)

 Base de donn√©es (ton carnet magique)
Une base de donn√©es = un carnet ultra-organis√© qui retient TOUT.

Exemple avec des utilisateurs :

```sql
TABLE "users"
```

```markdown
| id | nom | email | score |
|----|-----|-------|-------|
| 1 | Alice | <alice@mail.com> | 1250 |
| 2 | Bob | <bob@mail.com> | 890 |
| 3 | Charlie | <charlie@mail.com> | 2100 |
```

Pourquoi c'est important ?

- Persistance : M√™me si tu fermes l'app, tes donn√©es restent
- Partage : Plusieurs utilisateurs peuvent acc√©der aux m√™mes donn√©es
- Recherche : Tu peux retrouver "tous les joueurs avec un score > 1000"

---

#### **Les Frameworks** (tes super-outils)

Un framework = une bo√Æte √† outils avec des fonctions toutes pr√™tes.

Analogie : Construire une maison

Sans framework : Tu fabriques chaque clou, chaque planche, chaque vis √† la main üòµ
Avec framework : Tu as d√©j√† des murs pr√©fabriqu√©s, des portes standard, etc. üòé
Pour le web :
Sans framework : Tu √©cris tout le code JavaScript √† la main
Avec React : Tu as des "composants" tout pr√™ts (boutons, formulaires...)

Pour le projet j'utilise la pile **NestJS + React** et d√©finit tous les termes techniques employ√©s dans ce README.

---

#### **React (ton framework frontend)**

> Qu'est-ce que React ?

React est un framework JavaScript qui permet de cr√©er des composants r√©utilisables.

Exemple simple :

```jsx
function BoutonJouer() {
  return <button>Jouer au Pong !</button>;
}

function App() {
  return (
    <div>
      <h1>Mon Super Pong</h1>
      <BoutonJouer />
      <BoutonJouer />  {/* Je peux le r√©utiliser ! */}
    </div>
  );
}
```

Pourquoi c'est g√©nial ?

- R√©utilisable : Un composant = une pi√®ce LEGO (genre le bouton jouer)
- R√©actif : Si une donn√©e change l'affichage se met √† jour automatiquement (si tu change le score le score se met √† jour)
- Organis√© : Chaque bout de ton interface est dans son propre fichier (le bouton jouer est dans le fichier bouton_jouer.js)

---

#### **NestJS (ton framework backend)**

> Qu'est-ce que NestJS ?

NestJS est un framework Node.js qui permet de cr√©er des applications web et des services backend. Il organise ton backend en modules bien rang√©s.

Exemple d'utilisation :

```typescript
@Controller('pong')
export class PongController {
  @Get()
  getHello(): string {
    return 'Hello World!';
  }
}
```

Exemple d'organisation :

```typescript
AuthModule (tout ce qui concerne la connexion)
‚îú‚îÄ‚îÄ AuthController (les routes : /login, /register)
‚îú‚îÄ‚îÄ AuthService (la logique : v√©rifier le mot de passe)
‚îî‚îÄ‚îÄ AuthGuard (la s√©curit√© : "es-tu connect√© ?")

GameModule (tout ce qui concerne le jeu)
‚îú‚îÄ‚îÄ GameController (les routes : /start-game, /move-paddle)
‚îú‚îÄ‚îÄ GameService (la logique : calculer la position de la balle)
‚îî‚îÄ‚îÄ GameGateway (WebSockets : envoyer les positions en temps r√©el)
```

Les super-pouvoirs de NestJS :

- Modules : Tout est bien organis√© par domaine
- Injection de d√©pendances : Les services se "branchent" automatiquement
- D√©corateurs : @Get(), @Post() pour cr√©er des routes facilement
- Swagger automatique : La documentation de ton API se g√©n√®re toute seule !

#### **TypeScript (JavaScript avec des super-pouvoirs)**

JavaScript normal :

```javascript
function additionner(a, b) {
  return a + b;
}

additionner(5, "hello"); // üò± √áa marche mais √ßa donne "5hello" !
```

TypeScript :

```typescript
function additionner(a: number, b: number): number {
  return a + b;
}

additionner(5, "hello"); // ‚ùå ERREUR ! TypeScript dit "Non !"
```

Pourquoi c'est trop bien ?

- S√©curit√© : Moins de bugs bizarres
- Autocompl√©tion : Ton √©diteur conna√Æt tes variables
- Partage de types : Frontend et backend parlent le m√™me langage

---

#### **Prisma (ton assistant base de donn√©es)**

Le probl√®me sans Prisma :

```sql
SELECT users.name, games.score 
FROM users 
JOIN games ON users.id = games.user_id 
WHERE games.score > 1000;
```

üòµ Du SQL √† la main = gal√®re !

Avec Prisma :

```typescript
const topPlayers = await prisma.user.findMany({
  include: { games: true },
  where: { games: { some: { score: { gt: 1000 } } } }
});
```

üòé Du TypeScript lisible !

Les super-pouvoirs de Prisma :

- Sch√©ma visuel : Tu d√©cris tes tables en langage simple
- Migrations automatiques : Prisma met √† jour ta base de donn√©es
- Client typ√© : Autocompl√©tion pour toutes tes requ√™tes
- S√©curit√© : Protection contre les injections SQL

---

#### **WebSockets (le temps r√©el magique)**

Le probl√®me avec HTTP classique :

```markdown
Joueur 1 : "Je bouge ma raquette !" ‚Üí Serveur
Serveur : "OK re√ßu" ‚Üí Joueur 1
...
Joueur 2 : "O√π est la balle ?" ‚Üí Serveur  
Serveur : "Elle est l√†" ‚Üí Joueur 2
```

üòµ Trop lent pour un jeu en temps r√©el !

Avec WebSockets :

```markdown
Serveur ‚Üî Joueur 1 ‚Üî Joueur 2
üîÑ Connexion permanente : tout le monde re√ßoit les infos instantan√©ment !
```
  
Exemple concret avec Socket.io :

```typescript
// Backend (NestJS)
@WebSocketGateway()
export class GameGateway {
  @SubscribeMessage('paddle-move')
  handlePaddleMove(client: Socket, data: { x: number, y: number }) {
    // Diffuser √† tous les joueurs
    this.server.emit('paddle-updated', data);
  }
}

// Frontend (React)
socket.on('paddle-updated', (data) => {
  // Mettre √† jour la position de la raquette
  setPaddlePosition(data);
});
```

---

#### **Docker (tes conteneurs magiques)**

Analogie : Les conteneurs de transport

```markdown
üö¢ Un conteneur Docker = une bo√Æte standardis√©e qui contient tout ce qu'il faut pour faire tourner ton app.
```

Le probl√®me sans Docker :

```markdown
Ton PC : "√áa marche chez moi !" üòé
PC de ton pote : "√áa marche pas !" üò≠
Serveur de prod : "√áa plante !" üí•
```

Avec Docker √áa marche pareil partout !

Exemple pour ton projet :

```yaml
# docker-compose.yml
services:
  backend:
    build: ./backend
    ports:
      - "3001:3001"
    
  frontend:
    build: ./frontend  
    ports:
      - "3000:3000"
      
  database:
    image: postgres:15
    environment:
      POSTGRES_DB: transcendence
Une seule commande : docker-compose up ‚Üí Tout d√©marre ! üöÄ
```

---

#### **API REST**

> √áa va √™tre comment frontend et backend se parlent

***REST*** = **RE**presentational **S**tate **T**ransfer (fa√ßon standardis√©e de communiquer)

Exemple avec ton Pong :

```typescript
// Frontend demande
GET /api/users/123        ‚Üí "Donne-moi le profil du joueur 123"
POST /api/games           ‚Üí "Cr√©e une nouvelle partie"
PUT /api/games/456        ‚Üí "Met √† jour la partie 456"
DELETE /api/games/456     ‚Üí "Supprime la partie 456"

// Backend r√©pond
{
  "id": 123,
  "username": "Alice",
  "score": 1250,
  "games_played": 42
}
```

---

#### **Hooks React (La logique r√©utilisable)**

```tsx
// hooks/useGame.ts
function useGame() {
  const [score, setScore] = useState(0);
  const [isPlaying, setIsPlaying] = useState(false);
  
  const startGame = () => {
    setIsPlaying(true);
    // Logique de d√©marrage...
  };
  
  return { score, isPlaying, startGame };
}

// pages/Game.tsx
function Game() {
  const { score, isPlaying, startGame } = useGame();
  
  return (
    <div>
      <p>Score: {score}</p>
      {!isPlaying && <button onClick={startGame}>Jouer</button>}
    </div>
  );
}
```

---

#### **JWT (Authentification sans session)**

```typescript
// Quand tu te connectes
POST /api/auth/login
{
  "email": "alice@mail.com",
  "password": "motdepasse"
}

// Serveur r√©pond avec un token
{
  "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

// Ensuite, pour chaque requ√™te
GET /api/profile
Headers: { "Authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." }
```

---

### **4. Architecture du projet**

```markdown
transcendence/
‚îú‚îÄ‚îÄ docker-compose.yml              # üé≠ Le chef d'orchestre : lance tout
‚îú‚îÄ‚îÄ .env                            # üîê Secrets et config (mots de passe, URLs)
‚îú‚îÄ‚îÄ Makefile                        # üìù Commandes utiles
‚îÇ
‚îú‚îÄ‚îÄ backend/                        # üü¢ NestJS + TypeScript
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ package.json                # üîÑ Node.js
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json               # üîÑ Configuration TypeScript
‚îÇ   ‚îú‚îÄ‚îÄ nest-cli.json               # üîÑ Configuration NestJS
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.ts                 # üîÑ Point d'entr√©e NestJS
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.module.ts           # üîÑ Module racine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/                   # üü¢ Module d'authentification
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.module.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.controller.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth.service.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.guard.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game/                   # üü¢ Module de jeu
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game.module.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game.controller.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ game.service.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ game.gateway.ts     # üîÑ WebSockets
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ users/                  # üü¢ Module utilisateurs
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ users.module.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ users.controller.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ users.service.ts
‚îÇ   ‚îî‚îÄ‚îÄ prisma/                     # üîÑ Prisma ORM (structure de la BDD)
‚îÇ       ‚îú‚îÄ‚îÄ schema.prisma           # üîÑ Sch√©ma de base de donn√©es
‚îÇ       ‚îî‚îÄ‚îÄ migrations/             # üîÑ Migrations auto-g√©n√©r√©es
‚îÇ
‚îú‚îÄ‚îÄ frontend/                       # üü¢ React + TypeScript
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json               # üîÑ TypeScript pour React
‚îÇ   ‚îú‚îÄ‚îÄ vite.config.ts              # üîÑ Configuration Vite
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tsx                # üîÑ Point d'entr√©e React
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.tsx                 # üîÑ Composant racine
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/             # üü¢ Composants React (üß© Pi√®ces LEGO r√©utilisables)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Navbar.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Button.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GameCanvas.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/                  # üü¢ Pages de l'app (√©cran complet)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Home.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Game.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Profile.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/                  # üîÑ Custom hooks React (logique r√©utilisable)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/               # üîÑ API calls (interactions avec le backend)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/                  # üîÑ Types TypeScript partag√©s
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ styles/                 # üü¢ CSS/SCSS
‚îÇ   ‚îî‚îÄ‚îÄ public/
‚îÇ
‚îú‚îÄ‚îÄ database/                       # üü¢ PostgreSQL
‚îÇ
‚îú‚îÄ‚îÄ nginx/                          # üü¢ Reverse proxy
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ   ‚îú‚îÄ‚îÄ nginx.conf
‚îÇ   ‚îî‚îÄ‚îÄ ssl/
‚îÇ
‚îî‚îÄ‚îÄ monitoring/                     # üü¢ Module bonus
    ‚îú‚îÄ‚îÄ prometheus/
    ‚îî‚îÄ‚îÄ grafana/
```

‚öôÔ∏è **Backend/ (Le cerveau)**

Pourquoi s√©par√© par modules ?

- Maintenance : Bug dans l'auth ? Tu touches que le dossier auth/
- R√©utilisation : Le module users/ peut servir √† d'autres projets
- Tests : Tu peux tester chaque module ind√©pendamment

Exemple concret :

```typescript
// auth/auth.controller.ts ‚Üí Routes de connexion
@Post('login')
login(@Body() credentials) { ... }

// game/game.controller.ts ‚Üí Routes de jeu  
@Post('start-game')
startGame(@User() player) { ... }

// game/game.gateway.ts ‚Üí WebSockets temps r√©el
@SubscribeMessage('paddle-move')
handlePaddleMove(client, data) { ... }
```

üé® **Frontend/ (L'interface)**

Pourquoi s√©par√© ?

Components : Un bouton = un fichier ‚Üí r√©utilisable partout
Pages : Chaque √©cran = un fichier ‚Üí navigation claire
Services : Toutes les requ√™tes API au m√™me endroit
Types : Partage des types entre front et back
Exemple concret :

```tsx
// components/Button.tsx
export function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

// pages/Game.tsx  
import { Button } from '../components/Button';
function Game() {
  return <Button onClick={startGame}>Jouer !</Button>;
}

// services/gameApi.ts
export async function startGame() {
  return fetch('/api/game/start', { method: 'POST' });
}
```

üóÑÔ∏è **Database/ (La m√©moire)**

```bash
database/
‚îî‚îÄ‚îÄ # Juste l'image PostgreSQL officielle
```

Pourquoi s√©par√© ?

- Isolation : La DB tourne dans son propre conteneur
- S√©curit√© : Pas d'acc√®s direct depuis l'ext√©rieur
- Backup : Volumes Docker s√©par√©s pour sauvegarder
- Scaling : On peut changer de DB sans toucher au code

üö™ **Nginx/ (Le portier)**

```bash
nginx/
‚îú‚îÄ‚îÄ nginx.conf         # üõ°Ô∏è R√®gles de routage et s√©curit√©
‚îî‚îÄ‚îÄ ssl/               # üîí Certificats HTTPS
```

Pourquoi un **reverse proxy** ?

```bash
Internet ‚Üí Nginx ‚Üí Frontend (port 3000)
              ‚îî‚îÄ‚îÄ‚Üí Backend (port 3001)
```

- S√©curit√© : Une seule porte d'entr√©e
- HTTPS : Certificats SSL centralis√©s
- Cache : Images/CSS mis en cache
- Load balancing : R√©partir la charge (bonus)

> ‚ùî ***Mais Qu'est-ce qu'un Reverse Proxy ?***

Imagine un grand h√¥tel :

```bash
üè® H√îTEL (ton serveur)
‚îú‚îÄ‚îÄ üçΩÔ∏è Restaurant (Frontend - port 3000)
‚îú‚îÄ‚îÄ üèä Piscine (Backend - port 3001)  
‚îú‚îÄ‚îÄ üõèÔ∏è Chambres (Database - port 5432)
‚îî‚îÄ‚îÄ üö™ R√©ceptionniste (Nginx) ‚Üê Point d'entr√©e UNIQUE
```

Sans r√©ceptionniste (probl√©matique), un client qui veut se diriger vers le restaurant doit conna√Ætre l'√©tage et la porte, pareil pour la piscine et les chambres.

Avec r√©ceptionniste (Nginx) :

```bash
Client : "Bonjour !" ‚Üí au r√©ceptionniste
R√©ceptionniste : "Restaurant ? Par ici !" ‚Üí Redirige vers port 3000
R√©ceptionniste : "Piscine ? Par l√† !" ‚Üí Redirige vers port 3001
R√©ceptionniste : "Chambres ? Par l√† !" ‚Üí Redirige vers port 5432
```

üîÑ Comment √ßa marche concr√®tement ?

*Sans Nginx* :

```bash
üë§ Utilisateur
‚îú‚îÄ‚îÄ <https://monsite.com:3000> ‚Üí Frontend React
‚îî‚îÄ‚îÄ <https://monsite.com:3001> ‚Üí Backend NestJS
```

Probl√®mes...

- üòµ L'utilisateur doit conna√Ætre les ports
- üö´ CORS (Cross-Origin) : navigateur bloque les requ√™tes entre ports
- üîì Pas de HTTPS centralis√©
- üò∞ Plusieurs points d'entr√©e = failles de s√©curit√©

*Avec Nginx* :

```bash
üë§ Utilisateur ‚Üí <https://monsite.com> (port 443)
                        ‚Üì
                   üö™ Nginx (reverse proxy)
                        ‚Üì
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚Üì               ‚Üì               ‚Üì
   Frontend         Backend        Database
  (port 3000)     (port 3001)    (port 5432)
```

‚öôÔ∏è Configuration Nginx

```nginx
# nginx/nginx.conf
server {
    listen 80;
    server_name localhost;

    # Frontend (pages web)
    location / {
        proxy_pass http://frontend:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # Backend API
    location /api/ {
        proxy_pass http://backend:3001;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # WebSockets (temps r√©el)
    location /socket.io/ {
        proxy_pass http://backend:3001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
}
```

üéØ Les avantages pour le projet Pong

- Une seule URL

  - <https://monpong.com/>          ‚Üí Page d'accueil (React)
  - <https://monpong.com/game>      ‚Üí Jeu Pong (React)  
  - <https://monpong.com/api/login> ‚Üí Connexion (NestJS)
  - <https://monpong.com/api/game>  ‚Üí API jeu (NestJS)

- S√©curit√© renforc√©e

  - üîí HTTPS centralis√© : Un seul certificat SSL
  - üõ°Ô∏è Firewall : Nginx filtre les requ√™tes malveillantes
  - üö´ Ports cach√©s : L'ext√©rieur ne voit que le port 80/443

- Performance

  - ‚ö° Cache statique : Images, CSS, JS mis en cache
  - üì¶ Compression : Gzip automatique
  - üöÄ Load balancing : R√©partir la charge (si plusieurs backends)

- D√©veloppement simplifi√©

  - üîÑ Pas de CORS : Tout vient du m√™me domaine
  - üõ†Ô∏è Hot reload : Nginx redirige vers Vite dev server
  - üì± Mobile friendly : M√™me URL sur tous les appareils

Exemple concret

```markdown
Sc√©nario : Joueur lance une partie

1. üë§ Joueur tape : <https://monpong.com/game>
‚Üì
2. üö™ Nginx : "C'est une page ? ‚Üí Frontend !"
‚Üì  
3. üé® React affiche la page de jeu
‚Üì
4. üéÆ Joueur clique "Jouer" ‚Üí fetch('/api/start-game')
‚Üì
5. üö™ Nginx : "C'est /api/ ? ‚Üí Backend !"
‚Üì
6. ‚öôÔ∏è NestJS cr√©e la partie ‚Üí WebSocket
‚Üì
7. üö™ Nginx : "WebSocket ? ‚Üí Backend aussi !"
‚Üì
8. üé® React re√ßoit "Partie cr√©√©e !" en temps r√©el
R√©sultat : L'utilisateur ne voit qu'une seule URL, mais Nginx orchestre tout en arri√®re-plan ! üé≠
```

üîÑ **Comment tout communique ?**

```mermaid
    User[üë§ Utilisateur] --> Nginx[üö™ Nginx]
    Nginx --> Frontend[üé® React]
    Nginx --> Backend[‚öôÔ∏è NestJS]
    Frontend -.WebSocket.-> Backend
    Backend --> Database[üóÑÔ∏è PostgreSQL]
    Backend --> Prisma[üîß Prisma ORM]
```

Et en gros √ßa donne √ßa :

```markdown
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   NAVIGATEUR    ‚îÇ    ‚îÇ     SERVEUR     ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  React    ‚îÇ  ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ  ‚îÇ  NestJS   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ(Frontend) ‚îÇ  ‚îÇ    ‚îÇ  ‚îÇ(Backend)  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ        ‚îÇ        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇSocket.io  ‚îÇ  ‚îÇ‚óÑ‚îÄ‚îÄ‚ñ∫‚îÇ  ‚îÇSocket.io  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ(Temps     ‚îÇ  ‚îÇ    ‚îÇ  ‚îÇ(Gateway)  ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ r√©el)     ‚îÇ  ‚îÇ    ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ    ‚îÇ        ‚îÇ        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
                       ‚îÇ  ‚îÇ Prisma    ‚îÇ  ‚îÇ
                       ‚îÇ  ‚îÇ(ORM)      ‚îÇ  ‚îÇ
                       ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
                       ‚îÇ        ‚îÇ        ‚îÇ
                       ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
                       ‚îÇ  ‚îÇPostgreSQL ‚îÇ  ‚îÇ
                       ‚îÇ  ‚îÇ(Database) ‚îÇ  ‚îÇ
                       ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
                       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

Flow d'une action :

```markdown
User clique "Jouer" ‚Üí Frontend
Frontend ‚Üí HTTP ‚Üí Nginx ‚Üí Backend
Backend ‚Üí Prisma ‚Üí Database (cr√©er partie)
Backend ‚Üí WebSocket ‚Üí Frontend (confirmer)
Frontend affiche "Partie cr√©√©e !"
```

---

### **5. Setup**

#### **Installation des outils sur Windows**

Voici la liste minimale d'outils que j'utilise **sous Windows** :

- [Docker Desktop (WSL 2)](https://www.docker.com/products/docker-desktop/)
- [Git](https://git-scm.com/downloads)
- [Node.js LTS](https://nodejs.org/)
- [Python (incl. pip)](https://www.python.org/downloads/windows/)

Une fois install√©s je v√©rifie les versions :

```bash
C:\Users\ilymegy>docker --version
Docker version 28.3.2, build 578ccf6

C:\Users\ilymegy>docker-compose --version
Docker Compose version v2.38.2-desktop.1

C:\Users\ilymegy>git --version
git version 2.47.1.windows.2

C:\Users\ilymegy>node --version
v22.17.1

C:\Users\ilymegy>python --version
Python 3.13.5

C:\Users\ilymegy>pip --version
pip 25.1.1 from C:\Users\ilymegy\AppData\Local\Programs\Python\Python313\Lib\site-packages\pip (python 3.13)
```

#### **Initialisation du projet**

Voici les commandes pour initialiser mon projet :

```bash
# Initialiser le backend NestJS
cd backend
nest new . --package-manager pnpm --skip-git

# Installer les d√©pendances backend
pnpm add @nestjs/websockets @nestjs/config @nestjs/jwt @nestjs/passport passport-jwt socket.io @prisma/client
pnpm add -D prisma @types/passport-jwt

# Initialiser Prisma
npx prisma init

# Initialiser le frontend React/Vite
cd ../frontend
pnpm create vite . --template react-ts

# Installer les d√©pendances frontend
pnpm install
pnpm add axios socket.io-client zustand @chakra-ui/react @emotion/react @emotion/styled framer-motion
```

> Pour la petite explication des d√©pendances
**Backend :**

- `@nestjs/websockets` : Pour la communication en temps r√©el (jeu en ligne, chat)
- `@nestjs/config` : Gestion des variables d'environnement
- `@nestjs/jwt` & `passport-jwt` : Authentification s√©curis√©e avec JWT
- `socket.io` : Impl√©mentation des WebSockets
- `@prisma/client` : ORM pour la base de donn√©es
- `prisma` (dev) : Outils de d√©veloppement pour les migrations

**Frontend :**

- `axios` : Requ√™tes HTTP vers l'API
- `socket.io-client` : Connexion WebSocket avec le serveur
- `zustand` : Gestion d'√©tat l√©g√®re et performante
- `@chakra-ui/react` : Composants UI modernes et accessibles
- `@emotion/*` : Styles en JS requis par Chakra UI
- `framer-motion` : Animations fluides

Et on arrive √† une structure comme √ßa :

```bash
transcendence/
‚îú‚îÄ‚îÄ backend/               # Code source du backend
‚îÇ   ‚îú‚îÄ‚îÄ src/               # Code source NestJS
‚îÇ   ‚îú‚îÄ‚îÄ prisma/            # Sch√©ma et migrations Prisma
‚îÇ   ‚îú‚îÄ‚îÄ Dockerfile         # Configuration Docker
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ frontend/              # Code source du frontend
‚îÇ   ‚îú‚îÄ‚îÄ src/               # Composants React
‚îÇ   ‚îú‚îÄ‚îÄ public/            # Fichiers statiques
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ docker-compose.yml     # Configuration des conteneurs
‚îî‚îÄ‚îÄ .env                   # Variables d'environnement
```

#### **Initialisation compl√®te du projet**

Apr√®s avoir ex√©cut√© les commandes d'installation voici comment obtenir une structure compl√®te avec toutes les d√©pendances :

```bash
# Installer les d√©pendances du backend
cd backend
pnpm install

# G√©n√©rer le client Prisma
npx prisma generate

# Installer les d√©pendances du frontend
cd ../frontend
pnpm install

# Configurer le .env docker-compose.yml et les Dockerfiles
...

# D√©marrer les conteneurs Docker
cd ..
docker-compose up -d
```

Cette s√©quence va

1. Installer tous les modules Node.js n√©cessaires dans `backend/node_modules`
2. G√©n√©rer le client Prisma pour interagir avec la base de donn√©es
3. Installer toutes les d√©pendances frontend dans `frontend/node_modules`
4. Lancer les conteneurs Docker (base de donn√©es + backend)

> **Note** : Le premier d√©marrage peut prendre quelques minutes car Docker doit t√©l√©charger et construire les images n√©cessaires.

#### **Base de donn√©es**

Installe quelques **CLI Node** qui vont grandement simplifier la vie :

- **pnpm** : gestionnaire de paquets ultra-rapide (alternative √† npm/yarn).
- **@nestjs/cli** : g√©n√®re la structure d‚Äôun projet NestJS, des modules, contr√¥leurs, tests‚Ä¶
- **prisma** : outil de migrations + client TypeScript typ√© pour PostgreSQL.

```bash
# gestionnaire rapide
npm install -g pnpm

# CLI NestJS
pnpm add -g @nestjs/cli

# Prisma
pnpm add -g prisma
```

---

#### **Installation sur les PCs de l'√©cole (Ubuntu)**

```bash
# Cloner le projet
git clone <votre-repo> transcendence
cd transcendence

# Cr√©er le fichier d'environnement
cp .env.example .env

# √âditer .env avec vos configurations
-

# Lancer l'application
make up
# ou
docker-compose up --build
```

---

### **6. Commandes utiles**

#### **Docker**

```bash
# Lancer l'application
make up
docker-compose up --build

# Arr√™ter l'application
make down
docker-compose down

# Voir les logs
docker-compose logs -f backend
docker-compose logs -f frontend

# Acc√©der √† un conteneur
docker exec -it transcendence_backend_1 bash
docker exec -it transcendence_database_1 psql -U user -d transcendence

# Nettoyer
make clean
docker system prune -a

# Se connecter √† PostgreSQL
docker exec -it transcendence_database_1 psql -U user -d transcendence

# Commandes SQL utiles
\dt                    # Lister les tables
\d users              # D√©crire la table users
SELECT * FROM users;  # Voir tous les utilisateurs
```

#### **Frontend (React + Vite + TypeScript)**

```bash
# Installer les d√©pendances
pnpm install

# Lancer en mode d√©veloppement
pnpm dev

# Build pour production
pnpm build

# Pr√©visualiser le build de production localement
pnpm preview

# Lancer les tests
pnpm test

# Lancer le linter
pnpm lint

# Formater le code
pnpm format
```

#### **Backend (NestJS + Prisma)**

```bash
# Installer les d√©pendances
pnpm install

# Lancer en mode d√©veloppement (avec rechargement √† chaud)
pnpm run start:dev

# Build pour production
pnpm run build

# Lancer en production
pnpm run start:prod

# Ex√©cuter les migrations Prisma
npx prisma migrate dev --name init

# G√©n√©rer le client Prisma
npx prisma generate

# Lancer les tests
pnpm test

# Lancer le linter
pnpm lint

# Formater le code
pnpm format
```

#### **Acc√®s √† l'application**

- Frontend : <http://localhost:3000>
- Backend API : <http://localhost:8000/docs> (FastAPI)
- Base de donn√©es : localhost:5432

---

### **7. D√©veloppement par phases**

#### **Infrastructure**

- Setup Docker Compose
- Configuration base de donn√©es
- API backend minimal
- Interface frontend basique

#### **Authentification**

- Syst√®me de connexion/inscription
- Gestion des profils utilisateurs
- JWT tokens et s√©curit√©
- Upload d'avatars

#### **Jeu Pong**

- Canvas HTML5 et logique de jeu
- WebSockets pour le multijoueur
- Interface de jeu responsive
- Syst√®me de score

#### **Fonctionnalit√©s sociales**

- Historique des matchs
- Classements et statistiques
- Syst√®me d'amis (optionnel)
- Chat en temps r√©el (optionnel)

#### **Ma progression personnelle**

#### **Backend (NestJS)**

- Serveur op√©rationnel sur `localhost:8000`
  - Route de base (`/`) et sant√© (`/health`)
  - Configuration des contr√¥leurs et services

- Configuration Docker optimis√©e
  - Multi-stage build
  - Gestion des d√©pendances de production

- Int√©gration de Prisma avec PostgreSQL
  - Sch√©ma de base de donn√©es d√©fini
  - Migrations configur√©es
  - Client Prisma g√©n√©r√©

#### **La Base de donn√©es**

- Conteneur PostgreSQL fonctionnel
  - Persistance des donn√©es avec volumes Docker
  - Configuration s√©curis√©e

- Outils install√©s
  - Prisma ORM
  - @prisma/client
  - pg (driver PostgreSQL)

#### **Frontend**

- Configuration React + Vite + TypeScript
- Int√©gration de Chakra UI
- Gestion d'√©tat avec Zustand

- Composants principaux
  - Authentification
  - Tableau de bord
  - Interface de jeu

#### **Fonctionnalit√©s √† impl√©menter**

- Syst√®me d'authentification
- Logique du jeu Pong
- Chat en temps r√©el
- Gestion des matchs et classements

---

### **8. Checklist de progression**

#### **üèóÔ∏è Phase 1 : Infrastructure & Setup**

- [x] Cr√©er la structure de projet
- [X] Configurer Docker Compose
- [X] Setup PostgreSQL avec volumes
- [ ] Configuration Nginx de base
- [ ] Variables d'environnement (.env)
- [ ] Makefile avec commandes utiles
- [ ] Repository Git initialis√©

#### **‚öôÔ∏è Phase 2 : Backend API**

- [X] Framework backend choisi et install√©
- [ ] Mod√®les de donn√©es (User, Game, etc.)
- [ ] Endpoints d'authentification
  - [ ] POST /auth/register
  - [ ] POST /auth/login
  - [ ] GET /auth/me
- [ ] Endpoints utilisateurs
  - [ ] GET /users/{id}
  - [ ] PUT /users/{id}
  - [ ] POST /users/avatar
- [ ] Endpoints de jeu
  - [ ] POST /games/create
  - [ ] GET /games/{id}
  - [ ] GET /users/{id}/history
- [ ] Middleware de s√©curit√© (CORS, JWT)
- [ ] Tests API avec Postman

#### **üé® Phase 3 : Frontend Interface**

- [ ] Framework frontend choisi et configur√©
- [ ] Syst√®me de routing
- [ ] Pages principales cr√©√©es
  - [ ] Login/Register
  - [ ] Dashboard/Profile
  - [ ] Game interface
  - [ ] Lobby/Matchmaking
- [ ] Composants r√©utilisables
- [ ] Gestion d'√©tat (Context/Redux)
- [ ] Styles CSS/SCSS de base
- [ ] Responsive design mobile
- [ ] Connexion API backend

#### **üéÆ Phase 4 : Jeu Pong**

- [ ] Canvas HTML5 configur√©
- [ ] Logique de jeu impl√©ment√©e
  - [ ] Raquettes joueurs
  - [ ] Balle avec physique
  - [ ] D√©tection collisions
  - [ ] Syst√®me de score
- [ ] WebSockets pour multijoueur
  - [ ] Connexion/d√©connexion
  - [ ] Synchronisation √©tat jeu
  - [ ] Gestion latence
- [ ] Interface de jeu (HUD)
- [ ] Contr√¥les clavier/souris
- [ ] Animations et effets
- [ ] Mode spectateur (optionnel)

#### **üîê Phase 5 : Authentification & S√©curit√©**

- [ ] Syst√®me JWT complet
- [ ] Hachage mots de passe (bcrypt)
- [ ] Validation des entr√©es
- [ ] Protection CSRF
- [ ] Protection XSS
- [ ] HTTPS configur√©
- [ ] Rate limiting API
- [ ] Logs de s√©curit√©

#### **üìä Phase 6 : Fonctionnalit√©s sociales**

- [ ] Profils utilisateurs complets
- [ ] Historique des matchs
- [ ] Statistiques joueurs
- [ ] Classements/leaderboards
- [ ] Syst√®me d'amis (optionnel)
- [ ] Chat en temps r√©el (optionnel)
- [ ] Notifications (optionnel)

#### **üèÜ Phase 7 : Modules Bonus**

##### **Server-Side Pong + API (10 pts)**

- [ ] Logique Pong c√¥t√© serveur
- [ ] API endpoints pour le jeu
- [ ] Documentation API
- [ ] Tests unitaires

#### **Monitoring Prometheus/Grafana (5 pts)**

- [ ] Prometheus configur√©
- [ ] M√©triques applicatives
- [ ] Grafana dashboards
- [ ] Alertes configur√©es

#### **Multiple Languages (5 pts)**

- [ ] Syst√®me i18n configur√©
- [ ] 3+ langues support√©es
- [ ] S√©lecteur de langue
- [ ] Traductions compl√®tes

#### **Accessibility (5 pts)**

- [ ] Support screen readers
- [ ] Alt text pour images
- [ ] Navigation clavier
- [ ] Contraste √©lev√©
- [ ] Taille texte ajustable

#### **Advanced 3D Graphics (10 pts)**

- [ ] Babylon.js int√©gr√©
- [ ] Pong en 3D fonctionnel
- [ ] Effets visuels avanc√©s
- [ ] Performance optimis√©e

---

### **9. Ressources utiles**

#### **Documentation officielle**

- [Docker Documentation](https://docs.docker.com/)
- [PostgreSQL Docs](https://www.postgresql.org/docs/)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [React Documentation](https://react.dev/)
- [Socket.io Guide](https://socket.io/docs/)

#### **Tutoriels sp√©cialis√©s**

- [WebSocket avec JavaScript](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
- [HTML5 Canvas pour jeux](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial)
- [JWT Authentication](https://jwt.io/introduction/)
- [Docker Compose pour d√©veloppeurs](https://docs.docker.com/compose/gettingstarted/)

#### **Outils de d√©veloppement**

- **Postman** : Test des APIs
- **pgAdmin** : Interface PostgreSQL
- **Browser DevTools** : Debug frontend et WebSockets

#### Links

- [docker-compose.yml](https://github.com/Nimon77/ft_transcendence/blob/main/docker-compose.yml)
